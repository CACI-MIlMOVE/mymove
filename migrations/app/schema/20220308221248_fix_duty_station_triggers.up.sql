-- This trigger function is run before inserts/updates to service_members
-- In the old version, new.duty_location_id was unconditionally replaced with new.duty_station_id.
-- When we switch the Go model over to using the `duty_location_id` column instead of `duty_station_id`,
-- all the queries that get generated by app code will have NULL for `duty_station_id`, which will set off this trigger,
-- and the old version would have overwritten whatever we were trying to write to `duty_location_id` with NULL.
-- So in this new version we're checking a little more carefully before overwriting duty_location_id.
CREATE OR REPLACE FUNCTION copy_duty_station_id_to_duty_location_id()
	RETURNS TRIGGER
	LANGUAGE plpgsql AS
$$
BEGIN
	IF new.duty_location_id IS NULL OR
	   (new.duty_station_id IS NOT NULL AND new.duty_station_id <> old.duty_station_id) THEN
		new.duty_location_id := new.duty_station_id;
	END IF;
	RETURN new;
END
$$;

-- This trigger function is run before updates/inserts to orders.
-- The change is pretty much the same as the one above, but we're also taking
-- orders.new_duty_station/orders.new_duty_location out of the trigger because
-- keeping those columns in sync during the renaming is being handled entirely
-- by application code.
CREATE OR REPLACE FUNCTION copy_duty_station_ids_to_duty_location_ids()
	RETURNS TRIGGER
	LANGUAGE plpgsql AS
$$
BEGIN
	IF new.origin_duty_location_id IS NULL OR
	   (new.origin_duty_station_id IS NOT NULL AND new.origin_duty_station_id <> old.origin_duty_station_id) THEN
		new.origin_duty_location_id := new.origin_duty_station_id;
	END IF;
	RETURN new;
END
$$;

-- All app code that references these views has been removed in prior work
DROP VIEW duty_stations;
DROP VIEW duty_station_names;

-- We have to drop the NOT NULL constraint on this column before
-- we can stop writing to it. We have to stop writing to it before we
-- delete it entirely.
ALTER TABLE orders
	ALTER COLUMN new_duty_station_id DROP NOT NULL;
