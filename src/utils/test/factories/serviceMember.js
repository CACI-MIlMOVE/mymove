import { faker } from '@faker-js/faker';
import { build, oneOf, perBuild } from '@jackfranklin/test-data-bot';
import { v4 as uuidv4 } from 'uuid';

import serviceMemberAgencies from 'content/serviceMemberAgencies';
import addressFactory from 'utils/test/factories/address';
import fake from 'utils/test/factories/base';
import { ORDERS_RANK_OPTIONS } from 'constants/orders';
import WEIGHT_ENTITLEMENTS from 'constants/weightEntitlements';
import { phoneHelper } from 'utils/test/factories/helpers';

export const HAS_CURRENT_LOCATION = 'hasCurrentLocation';
export const HAS_BACKUP_MAILING_ADDRESS = 'hasBackupMailingAddress';
export const HAS_BACKUP_CONTACTS = 'hasBackupContacts';

const serviceMemberBuilder = build({
  fields: {
    id: perBuild(uuidv4),
    edipi: fake((f) => f.datatype.number({ min: 1000000000, max: 9999999999 })),
    affiliation: oneOf(...Object.keys(serviceMemberAgencies)),
    rank: oneOf(...Object.keys(ORDERS_RANK_OPTIONS)),
    first_name: fake((f) => f.name.firstName()),
    middle_name: fake((f) => f.name.middleName()),
    last_name: fake((f) => f.name.lastName()),
    telephone: phoneHelper,
    secondary_telephone: phoneHelper,
    email_is_preferred: fake((f) => f.datatype.boolean()),
    phone_is_preferred: fake((f) => f.datatype.boolean()),
    residential_address: addressFactory(),
    weight_allotment: {},
  },
  postBuild: (serviceMember) => {
    serviceMember.edipi += '';
    // These packages don't seem to have a way to do a weighed chance, so here's a way of doing having 1 in 4 chance of having a suffix
    const setSuffix = fake((f) => f.helpers.arrayElement([true, false, false, false]));

    if (setSuffix) {
      serviceMember.suffix = faker.name.suffix();
    }

    serviceMember.personal_email = faker.internet.exampleEmail(serviceMember.first_name, serviceMember.last_name);

    // Need at least one to be preferred...
    if (!serviceMember.email_is_preferred && !serviceMember.phone_is_preferred) {
      const preferredContactMethod = fake((f) => f.random.arrayElement(['email_is_preferred', 'phone_is_preferred']));

      serviceMember[preferredContactMethod] = true;
    }

    serviceMember.backup_mailing_address = addressFactory({
      overrides: {
        city: serviceMember.residential_address.city,
        state: serviceMember.residential_address.state,
      },
    });

    // overridden values take precedent of those generated by rank
    serviceMember.weight_allotment = {
      ...WEIGHT_ENTITLEMENTS[serviceMember.rank],
      ...serviceMember.weight_allotment,
    };

    return serviceMember;
  },
  traits: {
    [HAS_CURRENT_LOCATION]: {
      overrides: {
        current_location: {
          id: perBuild(uuidv4),
        },
      },
    },
    [HAS_BACKUP_MAILING_ADDRESS]: {
      overrides: {
        backup_mailing_address: addressFactory(),
      },
    },
    [HAS_BACKUP_CONTACTS]: {
      overrides: {
        backup_contacts: [
          {
            id: perBuild(uuidv4),
          },
        ],
      },
    },
  },
});

export default serviceMemberBuilder;
